#!/usr/bin/python3

import datetime
import os
import os.path
import requests
from signal import *
import socket
import subprocess
import threading
import logging
import sys
import time
import zmq
import waggle.logging

logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

beehive_reporter = waggle.logging.getLogger('wellness')

############################
##### Helper Functions #####
############################

# Run a command and capture it's output
def run_command(command):
  p = subprocess.Popen(command, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
  return iter(p.stdout.readline, b'')

# Get the Beehive server hostname
def get_beehive_hostname():
  server_host = ''
  try:
    with open('/etc/waggle/server_host', 'r') as f:
      server_host = f.readline().rstrip()
  except Exception:
    pass
  return server_host

beehive_hostname = get_beehive_hostname()

def reset_deadman_trigger():
  file = "/usr/lib/waggle/waggle_image/alive"
  rc = os.system("touch " + file + " > /dev/null 2>&1")
  if rc != 0:
    return False
  
def log_message(message):
  os.system("logger -t wellness " + message)

def send_to_beehive(type="INFO", data):
  """
    Send message to beehive through RabbitMQ running on the node
  """
  if type == "INFO":
    beehive_reporter.info(data)
  elif type == "ERROR":
    beehive_reporter.error(data)
  elif type == "DEBUG":
    beehive_reporter.debug(data)
  else:
    beehive_reporter.log(data)


###########################
##### Wellness Checks #####
###########################

# See whether file system recovery to the alternate bood medium
# has completed by checking for the existance of /root/do_recovery
def in_recovery():
  return os.path.isfile('/root/do_recovery')

# Check that there is a "Wireless" or "Realtek" (LAN) device
# connected to the USB hub
def check_USB_modem():
  output = run_command(['lsusb'])
  for line in output:
    if (b"Wireless" in line) or \
       (b"Realtek" in line):
      return True, line

  return False, 'None'

# Check that there is an IP address listed in either the PPP or
# eth1 info of ifconfig
def check_network_interface():
  output = run_command(['ifconfig'])
  next_line = False
  for line in output:
    if (b"eth0" in line):
      continue
    if (b"Point-to-Point Protocol" in line) or \
       (b"eth" in line):
      next_line = True
    elif next_line and (b"inet addr:" in line):
      return True, line
    else:
      next_line = False
  return False, 'None'

# DNS lookup of the Beehive server hostname
def check_beehive_DNS():
  hostname = beehive_hostname
  beehive_ip = ''
  try:
    beehive_ip = socket.gethostbyname(hostname)
  except Exception as e:
    return False, str(e)

  return True, 'Success'

# Ping the Beehive server
# The ICMP port is disabled on the beehive servers for external IPs, so
# just check that the beehive web portal is up
def check_beehive_ping():
  hostname = beehive_hostname
  rc = os.system("curl " + hostname + "/api/ > /dev/null 2>&1")
  if rc != 0:
    return False, "Failed"

  return True, "Success"

# Connect to the local sshd
def check_local_sshd():
  # To test, add "waggle" user to ThinkPad and setup passwordless key
  command = ['ssh -i /usr/lib/waggle/SSL/guest/id_rsa_waggle_aot_guest_node -x',
             '-o "PasswordAuthentication no"',
             '-o "StrictHostKeyChecking no"',
             '-o "ConnectTimeout 1" waggle@10.31.81.10',
             'date > /dev/null 2>&1']
  #print(' '.join(command))
  rc = os.system(' '.join(command))
  if rc != 0:
    return False, "Failed"

  return True, "Success"


# Connect to the Beehive server's sshd
def check_beehive_sshd():
  hostname = beehive_hostname
  command = ['ssh -i /usr/lib/waggle/SSL/node/key.pem -x',
             '-o "PasswordAuthentication no"',
             '-o "StrictHostKeyChecking no"',
             'root@'+hostname, '-p 20022',
             'date > /dev/null 2>&1']
  #print(' '.join(command))
  rc = os.system(' '.join(command))
  if rc != 0:
    return False, "Failed"

  return True, "Success"

def get_host_name():
  """
    Returns host name containing which device (from uSD and eMMC) is used to boot 
  """
  ret = ""
  try:
    ret = subprocess.getoutput(["uname -n"])
  except Exception as e:
    return False, "error on getting host name: %s" % str(e)
  return True, ret

def get_boot_info(history_count=3):
  """
    Returns history of reboot and shutdown.
  """
  ret = ""
  try:
    ret = subprocess.getoutput(["last -x reboot | head -n %d" % (history_count)])
  except Exception as e:
    return False, "error on getting boot messages: %s" % str(e)
  return True, ret

def get_shutdown_info(history_count=4):
  """
    Returns history of reboot and shutdown.
  """
  ret = ""
  try:
    ret = subprocess.getoutput(["last -x shutdown | head -n %d" % (history_count)])
  except Exception as e:
    return False, "error on getting shutdown messages: %s" % str(e)
  return True, ret

def disk_usage(path="/"):
  """Return disk usage statistics about the given path.

  Returned valus is a named tuple with attributes 'total', 'used' and
  'free', which are the amount of total, used and free space, in bytes.
  """
  total = used = free = 0
  ret = ""
  try:
    st = os.statvfs(path)
    free = st.f_bavail * st.f_frsize
    total = st.f_blocks * st.f_frsize
    used = (st.f_blocks - st.f_bfree) * st.f_frsize
    ret = "(total=%d, used=%d, free=%d)" % (total, used, free)
  except Exception as e:
    return False, "Failed"
  return True, ret

def get_current_cpu_temp():
  temperature_file = '/sys/class/thermal/thermal_zone0/temp'
  tempC = 0
  if os.path.isfile(temperature_file):
    return True, str(int(open(temperature_file).read()) / 1e3)
  else:
    return False, "Temp not available"

class wagmanListener(threading.Thread):
  '''
    A thread to listen Wagman status from the ZMQ publisher
  '''
  def __init__(self):
    threading.Thread.__init__(self)
    self.socket = None
    self.isConnected = False
    self.isClosed = False

    self.nc_hb = self.gn_hb = self.cs_hb = 0
    self.status = {}
    self.currents = self.temp = self.hb = {'nc':-100, 'gn':-100, 'cs':-100}
    self.error = ""

  def close(self):
    self.isClosed = True
    if self.isConnected:
      self.disconnect()

  def connect(self):
    context = zmq.Context()
    self.socket = context.socket(zmq.SUB)
    self.socket.setsockopt(zmq.RCVTIMEO, 3000)
    self.socket.setsockopt(zmq.SUBSCRIBE, b'')
    self.socket.connect ('ipc:///tmp/zeromq_wagman-pub')
    self.nc_hb = self.gn_hb = self.cs_hb = 0

  def disconnect(self):
    if self.socket != None and self.isConnected:
      self.socket.close()
      self.isConnected = False

  def get(self, key):
    if 'error' in key:
      return self.error
    elif 'status' in key:
      return str(self.status)
    elif 'current' in key:
      return str(self.currents)
    elif 'temp' in key:
      return str(self.temp)
    elif 'hb' in key or 'heartbeat' in key:
      return str(self.hb)
    else:
      return ""

  def run(self):
    while not self.isClosed:
      msg = ""
      try:
        msg = socket.recv_string()
      except (zmq.ZMQError, Exception) as e:
        log_message("Wagman Listener failed %s" % str(e))
        self.disconnect()
        time.sleep(3)
        self.connect()

      if not msg:
        continue

      prefix, _, content = message.partition(':')
      if prefix == "error":
        self.error = content
        continue
      prefix, _, content = (content.strip()).partition(' ')

      #********************************************#******************************************#
      # prefix                   # content                  #
      #********************************************#******************************************#
      # id (wagman id)               #                      #
      # date (wagman system date)          #                      #
      # cu (consumming current in each power tab)  #                      #
      # th (temperature difference between checks) #                      #
      # fails (# of fail to turn on)         #                      #
      # enabled (tab status)             #                      #
      # media (boot media)             #  SD / EMMC               #
      # gn (guest node)              #  hbeat / start / fault timeout / killing #
      # nc (nodecontroller)            #  hbeat                   #
      # cs (coresense)               #  hbeat / start             #
      #********************************************#******************************************#

      if prefix == "nc":
        if content == "heartbeat":
          self.nc_hb += 1
        else:
          self.status['nc_info'] = content

      elif prefix == "gn":
        if content == "heartbeat":
          self.gn_hb += 1
        else:
          self.status['gn_info'] = content
          
      elif prefix == "cs":
        if content == "heartbeat":
          self.cs_hb += 1
        else:
          self.status['cs_info'] = content
      
      elif prefix == "th":
        try:
          splits = content.split(' ')
          if len(splits) < 3:
            pass
          else:
            self.temp['nc'] = splits[0]
            self.temp['gn'] = splits[1]
            self.temp['cs'] = splits[2]
        except:
          pass

      elif prefix == "cu":
        try:
          splits = content.split(' ')
          if len(splits) < 3:
            pass
          else:
            self.currents['nc'] = splits[0]
            self.currents['gn'] = splits[1]
            self.currents['cs'] = splits[2]
        except:
          pass

      else:
        self.status[prefix] = content

        if prefix == "media":
          self.hb['nc'] = str(self.nc_hb) + "/6"
          self.hb['gn'] = str(self.gn_hb) + "/6"
          self.hb['cs'] = str(self.cs_hb) + "/6"

          self.nc_hb = 0
          self.gn_hb = 0
          self.cs_hb = 0

    self.disconnect()

# Run Wagman Listener
wagman_status = wagmanListener()
wagman_status.start()

# Check that we can read any WagMan status messages
def check_wagman_status():
  if not wagman_status.isClosed:
    msg = wagman_status.get('status')
    return True, msg
  else:
    return False, "Wagman listener not available"

# Check that we can read any WagMan status messages
def check_wagman_failure():
  if not wagman_status.isClosed:
    msg = wagman_status.get('error')
    if not msg:
      return False, "Warning %s" % msg
    return True, msg
  else:
    return False, "Wagman listener not available"

def get_wagman_curr():
  """
    Get from Wagman the currents being consumed in each power tab 
  """
  if not wagman_status.isClosed:
    msg = wagman_status.get('current')
    return True, msg
  else:
    return False, "Wagman listener not available"

def get_wagman_temp():
  """
    Get temperature difference between checks
  """
  if not wagman_status.isClosed:
    msg = wagman_status.get('temp')
    return True, msg
  else:
    return False, "Wagman listener not available"

def get_wagman_hb():
  """
    Get heartbeats of devices
  """
  if not wagman_status.isClosed:
    msg = wagman_status.get('hb')
    return True, msg
  else:
    return False, "Wagman listener not available"

#########################
##### Interventions #####
#########################

def reset_wagman():
  os.system("/usr/lib/waggle/waggle_image/scripts/reset_wagman.sh")

# Check list
#   contains category, entity, how to inspect, cycle (in seconds), report when fails...
#   function must return True/False result and corresponding message in a list
checklist = [
  # system check
  ['system', 'Disk available', disk_usage, 1800, True],
  ['system', 'Host name', get_host_name, 10000, False],
  ['system', 'Reboots', get_boot_info, 10000, False],
  ['system', 'Shutdowns', get_shutdown_info, 10000, False],
  ['system', 'Temperature', get_current_cpu_temp, 60, True],
  ['system', 'USB Modem', check_USB_modem, 60, False],
  ['system', 'Network Interface', check_network_interface, 60, False],
  ['system', 'Local sshd', check_local_sshd, 60, False],
  # Wagman check
  ['wagman', 'Wagman status', check_wagman_status, 60, False],
  ['wagman', 'Wagman Comm. failure', check_wagman_failure, 1, True],
  ['wagman', 'Wagman power consumption', get_wagman_curr, 60, True],
  ['wagman', 'Wagman temp', get_wagman_temp, 60, True],
  ['wagman', 'Wagman heartbeats', get_wagman_hb, 6, False],
  # Beehive check
  ['beehive', 'Beehive DNS', check_beehive_DNS, 1800, False],
  ['beehive', 'Beehive ping', check_beehive_ping, 1800, False],
  ['beehive', 'Beehive SSHD', check_beehive_sshd, 1800, False]
]

last_wagman_status_time = time.time()
max_wagman_silence_duration = 600  # (seconds) 10 minutes

""" ################################## """
""" Clean up when script is terminated """
""" ################################## """
def cleanup(signum, stack_frame):
  wagman_status.close()
  quit()
for sig in (SIGINT, SIGQUIT, SIGTERM):
  signal(sig, cleanup)
""" ################################## """

status = {}
LAST_UPDATED = 'last_updated'
RESULT = 'result'
MSG = 'message'

logging.info("Wellness service started")
while True:
  current_time = time.time()

  # Recovery status check
  if in_recovery():
    reset_deadman_trigger()
    log_message("Node Controller is performing a file system recovery.")

  # Contains any check item that should be reported
  reporting = []

  # Do checking
  # TODO: checking in parallel might be necessary as items in the list increases
  for category, entity, func, period, report in checklist:
    # Create item if not exist
    if category not in status:
      status[category] = {}
    if entity not in status[category]:
      status[category][entity] = {}
      status[category][entity][LAST_UPDATED] = time.time() - 100000

    item = status[category][entity]
    # If the item needs to be checked
    if time.time() - item[LAST_UPDATED] > period:
      result = False
      try:
        result, msg = func()
        item[RESULT] = result
        item[MSG] = msg
      except Exception as e:
        item[RESULT] = False
        item[MSG] = 'Function %s call failed: %s' % (str(func), str(e))

      if not result and report:
        logging.info("Failure in %s" % str({'category':category,'entity':entity}.update(item)))
        reporting.append({'entity':entity}.update(item))

      logging.debug("update performed %s:%s -> %s" % (category, entity, str(item)))
      item[LAST_UPDATED] = time.time()
      status[category][entity] = item

  if reporting:
    for item in reporting:
      send_to_beehive(str(item))
    reporting = []
  # Prevent using max CPU
  time.sleep(0.5)



  # # Local checks (done every minute)
  # #print("Performing local checks...")
  # local_check_results = [check_USB_modem(),
  #                        check_network_interface(),
  #                        check_local_sshd()]

  # # Beehive checks
  # beehive_check_results = []
  # print("Performing Beehive checks...")
  # if (current_time - beehive_check_time) > beehive_check_duration:
  #   beehive_check_results = [check_beehive_DNS(beehive_hostname),
  #                            check_beehive_ping(beehive_hostname),
  #                            check_beehive_sshd(beehive_hostname),]
  #   if all(beehive_check_results):
  #     beehive_check_time = time.time()

  # # Reset deadman trigger if all local and Beehive checks have passed
  # results = local_check_results + beehive_check_results
  # if all(results):
  #   #print("Resetting deadman trigger...")
  #   reset_deadman_trigger()
  #   #print("Node Controller is well.")
  #   log_message("Node Controller is well.")
  # else:
  #   #print("Logging test failures...")
  #   log_message("The following tests failed: " + 
  #               str([n for x,n in zip(results,test_names) if not x]) + "\n")

  # # WagMan checks
  # print("Performing wagman checks...")
  # if check_wagman_status(wagman_status):
  #   # WagMan is still sending updates
  #   last_wagman_status_time = time.time()
  # else:
  #   # WagMan stopped sending updates
  #   current_time = time.time()
  #   wagman_silence_duration = current_time - last_wagman_status_time
  #   if wagman_silence_duration >= max_wagman_silence_duration:
  #     log_message("WagMan is not well. Resetting WagMan...")
  #     reset_wagman()
  #     last_wagman_status_time = time.time()

  # time.sleep(base_sleep_time)
